builtin lists;
builtin random;
builtin numbers;
builtin clock;
builtin media;



structure CellCoordinates {
    x: num;
    y: num;
}


structure Snake {
    # last one is the head
    cells: list[CellCoordinates];
    # 0 = top, 1 = right, 2 = bottom, 3 = left
    direction: num;
    # If the snake should grow (= keep the last cell) at the next move
    keep: bool;
}


structure Grid {
    w: num;
    h: num;
    snake: Snake;

    fruit_pos: CellCoordinates;
}




# Move the snake by one cell
define move for Grid: -> bool {
    snake_head_pos = @self.snake.cells[- @self.snake.cells.len() 1];
    # Add a new cell to the snake
    if == @self.snake.direction 0 {
        if == snake_head_pos.y 0 {
            new_head = new CellCoordinates(snake_head_pos.x - @self.h 1);
        };
        if !== snake_head_pos.y 0 {
            new_head = new CellCoordinates(snake_head_pos.x - snake_head_pos.y 1);
        };
    };
    if == @self.snake.direction 1 {
        if == snake_head_pos.x - @self.w 1 {
            new_head = new CellCoordinates(0 snake_head_pos.y);
        };
        if !== snake_head_pos.x - @self.w 1 {
            new_head = new CellCoordinates(+ snake_head_pos.x 1 snake_head_pos.y);
        };
    };
    if == @self.snake.direction 2 {
        if == snake_head_pos.y - @self.h 1 {
            new_head = new CellCoordinates(snake_head_pos.x 0);
        };
        if !== snake_head_pos.y - @self.h 1 {
            new_head = new CellCoordinates(snake_head_pos.x + snake_head_pos.y 1);
        };
    };
    if == @self.snake.direction 3 {
        if == snake_head_pos.x 0 {
            new_head = new CellCoordinates(- @self.w 1 snake_head_pos.y);
        };
        if !== snake_head_pos.x 0 {
            new_head = new CellCoordinates(- snake_head_pos.x 1 snake_head_pos.y);
        };
    };


    # if the new head is on the snake's body, return "false", so the program stops
    game_over = @self.snake.cells.contains(new_head);
    if game_over {
        @return = false;
    };
    if !game_over {
        @self.snake.cells.push(new_head);
        # remove the last cell of the snake, if it is not growing
        if !@self.snake.keep {
            @self.snake.cells.pull(0);
        };
        if @self.snake.keep {
            @self.snake.keep = false;
        };

        # if the new head is on a fruit, change the fruit position and set keep to true
        if == new_head @self.fruit_pos {
            @self.snake.keep = true;
            @self.fruit_pos = new CellCoordinates(range(0 @self.w).floor() range(0 @self.h).floor());
        };

        @return = true;
    };
}





# Draw on the canvas the current state of the grid
define draw for Grid: ~Canvas -> num {
    # clear screen
    @0.set_rect(0 0 400 400 16 66 38);

    # draw the snake
    y = 0;
    while < y @self.h {
        x = 0;
        while < x @self.w {
            co = new CellCoordinates(x y);

            # Draw the fruit in red
            if == @self.fruit_pos co {
                @0.set_rect(* x 20 * y 20 20 20 168 50 78);
            };

            # Draw each snake cells in white
            if @self.snake.cells.contains(co) {
                @0.set_rect(* x 20 * y 20 20 20 255 255 255);
            };
            x = + x 1;
        }; 
        y = + y 1;
    };

    @0.update();
}








# Return a new grid of the given size, with a randomly placed snake of length 1
define new_random_grid: num num -> Grid {
    snake_start_pos = new CellCoordinates(range(0 @0).floor() range(0 @1).floor());
    s = new Snake([snake_start_pos] 0 false);

    fruit_pos = new CellCoordinates(range(0 @0).floor() range(0 @1).floor());

    @return = new Grid(@0 @1 s fruit_pos);
}






define main: -> num {
    grid = new_random_grid(20 20);
    
    canvas = new Canvas("Snake" 400 400);

    close = false;
    timer = clock:now();
    while !close {
        close = false;

        # Move the snake from time to time
        duration_since_update = timer.since();
        if > duration_since_update.ms 300 {

            # move() returns false in case the snake has eaten itself (game over)
            if !grid.move() {
                close = true;
                print("Game over! Score: " grid.snake.cells.len() "\n");
            };
            timer = clock:now();
        };


        # Update snake direction
        event = media:last_event();
        if == event "EVENT_UP" {grid.snake.direction = 0;};
        if == event "EVENT_RIGHT" {grid.snake.direction = 1;};
        if == event "EVENT_DOWN" {grid.snake.direction = 2;};
        if == event "EVENT_LEFT" {grid.snake.direction = 3;};


        # Draw screen
        grid.draw(canvas);


        # close condition
        if == event "EVENT_QUIT" {close = true;};
    };
}