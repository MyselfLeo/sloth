builtin lists;
builtin random;
builtin numbers;
builtin clock;
builtin media;



structure CellCoordinates {
    x: num;
    y: num;
}


structure Snake {
    # last one is the head
    cells: list[CellCoordinates];
    # 0 = top, 1 = right, 2 = bottom, 3 = left
    direction: num;
    # If the snake should grow (= keep the last cell) at the next move
    keep: bool;
}


structure Grid {
    w: num;
    h: num;
    snake: Snake;
}



# Print the grid to the console
define debug for Grid: -> num {
    y = 0;

    while < y @self.h {
        x = 0;

        while < x @self.w {

            co = new CellCoordinates(x y);

            res = @self.snake.cells.contains(co);
            if res {
                if == @self.snake.direction 0 {print("^ ");};
                if == @self.snake.direction 1 {print("> ");};
                if == @self.snake.direction 2 {print("v ");};
                if == @self.snake.direction 3 {print("< ");};
            };
            if !res {
                print("_ ");
            };

            x = + x 1;
        }; 

        print("\n");
        y = + y 1;
    };
}



# Move the snake by one cell
define move for Grid: -> num {
    snake_head_pos = @self.snake.cells[- @self.snake.cells.len() 1];
    # Add a new cell to the snake
    if == @self.snake.direction 0 {
        if == snake_head_pos.y 0 {
            @self.snake.cells.push(new CellCoordinates(snake_head_pos.x - @self.h 1));
        };
        if !== snake_head_pos.y 0 {
            @self.snake.cells.push(new CellCoordinates(snake_head_pos.x - snake_head_pos.y 1));
        };
    };
    if == @self.snake.direction 1 {
        if == snake_head_pos.x - @self.height 1 {
            @self.snake.cells.push(new CellCoordinates(0 snake_head_pos.y));
        };
        if !== snake_head_pos.x - @self.height 1 {
            @self.snake.cells.push(new CellCoordinates(+ snake_head_pos.x 1 snake_head_pos.y));
        };
    };
    if == @self.snake.direction 2 {
        if == snake_head_pos.y - @self.height 1 {
            @self.snake.cells.push(new CellCoordinates(snake_head_pos.x 0));
        };
        if !== snake_head_pos.y - @self.height 1 {
            @self.snake.cells.push(new CellCoordinates(snake_head_pos.x + snake_head_pos.y 1));
        };
    };
    if == @self.snake.direction 3 {
        if == snake_head_pos.x 0 {
            @self.snake.cells.push(new CellCoordinates(- @self.w 1 snake_head_pos.y));
        };
        if !== snake_head_pos.x 0 {
            @self.snake.cells.push(new CellCoordinates(- snake_head_pos.x 1 snake_head_pos.y));
        };
    };

    # remove the last cell of the snake, if it is not growing
    if !@self.snake.keep {
        @self.snake.cells.pull(0);
    };
}





# Draw on the canvas the current state of the grid
define draw for Grid: ~Canvas -> num {
    # clear screen
    @0.set_rect(0 0 400 400 0 0 0);

    # draw the snake
    y = 0;
    while < y @self.h {
        x = 0;
        while < x @self.w {
            co = new CellCoordinates(x y);
            if @self.snake.cells.contains(co) {
                @0.set_rect(* x 20 * y 20 20 20 255 255 255);
            };
            x = + x 1;
        }; 
        y = + y 1;
    };

    @0.update();
}








# Return a new grid of the given size, with a randomly placed snake of length 1
define new_random_grid: num num -> Grid {
    snake_start_pos = new CellCoordinates(range(0 @0).floor() range(0 @1).floor());
    s = new Snake([snake_start_pos] 0 false);

    @return = new Grid(@0 @1 s);
}






define main: -> num {
    grid = new_random_grid(20 20);
    
    canvas = new Canvas("Snake" 400 400);

    close = false;
    timer = clock:now();
    while !close {

        duration_since_update = timer.since();
        if > duration_since_update.ms 750 {
            grid.move();
            print("updated\n");
            timer = clock:now();
        };


        grid.draw(canvas);


        close = media:check_event("EVENT_QUIT");
    };
}